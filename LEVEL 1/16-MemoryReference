## 16. Memory Reference

### 메모리 관리에서 강한 참조(Strong Reference)와 약한 참조(Weak Reference)의 차이점은 무엇인가요?
- 강한 참조
    - 기본적인 참조 방식
    - 객체를 소유하며 객체의 참조 카운트를 증가시킨다.
    - 참조 카운트가 0이 될 때 메모리가 해제되므로, 강한 참조는 객체가 메모리에서 해제되지 않도록 유지한다.
- 약한 참조
    - 객체의 수명이 끝났는지 관찰하기 위해 사용되기에 관찰된 객체 수명(Observed Object's lifetime)이라고도 한다. 관찰된 객체 수명에는 Weak, Unowned, Deinit과 같은 키워드들이 있다.
    - 객체를 소유하지 않는 참조 방식.
    - 참조 카운트를 증가시키지 않으므로 객체의 라이프사이클에 영향을 주지 않는다.
    - 약한 참조는 항상 **옵셔널 타입**이어야 하며, 참조 대상 객체가 해제되면 자동으로 `nil`이 된다.



### 순환 참조(Retain Cycle)가 발생하는 경우와 해결 방법은 무엇인가요?
순환 참조는 두 객체가 서로를 강하게 참조하여, 각각의 변수에서는 할당을 해제했음에도 서로의 참조 카운트를 감소시킬 수 없는 상태를 말한다. 때문에 객체가 메모리에서 해제되지 않아 메모리 누수(Memory Leak)가 발생한다.
![image](https://hackmd.io/_uploads/rJoIuQ9UJe.png)




### 클로저에서 [weak self]와 [unowned self]의 차이는 무엇인가요?
- weak self
    - 약한 참조
    - 캡처한 객체가 해제될 수 있으므로, `self`는 **옵셔널**로 처리
    - 클로저 내부에서 `self`를 사용할 때 반드시 안전하게 옵셔널 바인딩을 해야 한다.
    - 객체가 해제될 수 있는 상황에 적합하다.
- unowned self
    - 비소유 참조
    - 캡처한 객체가 해제되지 않는다고 확신할 때 사용.
    - `self`는 **옵셔널이 아니며 강제 언래핑 없이 사용**할 수 있다.
    - 객체가 이미 해제되었는데 접근하려 하면 **런타임 에러**가 발생한다.
- 객체가 클로저 생명 주기 동안 반드시 존재한다고 보장되면 unowned self를 사용해 성능을 최적화할 수 있다.
![image](https://hackmd.io/_uploads/Sk2eFQ58Jg.png)

### + weak와 unowned의 차이가 생겨나는 이유가 무엇일까?
- 사이드 테이블의 생성 여부에 따라 차이가 생깁니다.
- weak를 사용하면, Side Table이 생겨나고 객체에서는 해당 SideTableEntry를 가지게 됩니다. 즉, weak는 sideTable을 통해 접근하기에 객체가 메모리에서 해제 될 경우 nil을 할당하지만 unowned는 객체 자체에 접근하기에 객체가 메모리에서 해제될 경우 바로 crash를 발생하게 됩니다. 
